{
  "name": "mongoose-auth",
  "description": "User authentication plugin for mongoose node.js orm",
  "version": "0.0.12",
  "homepage": "https://github.com/bnoguchi/mongoose-auth/",
  "repository": {
    "type": "git",
    "url": "git://github.com/bnoguchi/mongoose-auth.git"
  },
  "author": {
    "name": "Brian Noguchi",
    "email": "brian.noguchi@gmail.com",
    "url": "https://github.com/bnoguchi/"
  },
  "main": "./index.js",
  "directories": {
    "lib": "."
  },
  "dependencies": {
    "bcrypt": ">=0.5.0",
    "mongoose": ">=2.4.8",
    "everyauth": ">=0.2.28",
    "mongoose-types": ">=1.0.3"
  },
  "devDependencies": {
    "express": ">=2.3.2",
    "jade": ">=0.12.1",
    "mocha": ">=0.10.1",
    "should": ">=0.5.1"
  },
  "scripts": {
    "test": "make"
  },
  "engines": {
    "node": ">=0.4.0"
  },
  "readme": "mongoose-auth\n=============\n\nUser authentication plugin for mongoose node.js orm.\n\nmongoose-auth enables you to support authorization in any number of ways\nvia authorization strategies.\n\nAn authorization strategy is how you authorize your user. Currently\nmongoose-auth supports the following authorization strategies:\n\n- `password`\n- `facebook`\n- `twitter`\n- `github`\n- `instagram`\n- `google`\n\nmongoose-auth does 3 things:\n\n1. Schema decoration\n2. (optional) Drop in routing for \n   [connect](https://github.com/senchalabs/connect) apps.\n3. (optional) Dynamic helpers for \n   [express](https://github.com/visionmedia/express) apps.\n\nIt integrates the [everyauth](https://github.com/bnoguchi/everyauth) module\nto help it take care of the routing and helpers. everyauth is a general\npurpose npm module for authentication & authorization that can be used\nindependently of mongoose.\n\n## Schema Decoration\n\nAs you add successive authorization strategies, mongoose-auth at a bare\nminimum augments your schema with typed attributes corresponding to parameters\nrelated to your chosen authorization strategies. For example, if facebook is \none of your authorization strategies, then it will add attributes to your \nUser Schema such as 'fb.id' and 'fb.email'.\n\nTo decorate your schema:\n\n```javascript\n    var mongoose = require('mongoose')\n      , Schema = mongoose.Schema\n      , mongooseAuth = require('mongoose-auth');\n    \n    var UserSchema = new Schema({});\n    UserSchema.plugin(mongooseAuth, {\n      facebook: true\n    });\n```\n\n## Beyond Schema Decoration: Routing\n\nApplications require more than just User Schema augmentation in order\nto implement a complete authorization strategy. Applications also need\nroutes exposing the one or more steps involved for a given authorization\nstrategy. Moreover, applications each handle in their own unique way how\nthey want to respond to successful or failed logins (in addition to logout\nhandling). If you are not using a \n[connect](https://github.com/senchalabs/connect), then you will have to\nset all of this up yourself. In this case, mongoose-auth *only* provides\nyou with Schema decoration.\n\nBut, if you are building your app on top of\n[connect](https://github.com/senchalabs/connect), then mongoose-auth\nprovides drop in solutions for you. Here is how you can get access\nto the routing that mongoose-auth provides. Not the \"STEP X: ...\"\ncomments:\n\n```javascript\n    var mongoose = require('mongoose')\n      , Schema = mongoose.Schema\n      , mongooseAuth = require('mongoose-auth');\n    \n    var UserSchema = new Schema({})\n      , User;\n   \n    // STEP 1: Schema Decoration and Configuration for the Routing\n    UserSchema.plugin(mongooseAuth, {\n        // Here, we attach your User model to every module\n        everymodule: {\n          everyauth: {\n              User: function () {\n                return User;\n              }\n          }\n        }\n        \n      , facebook: {\n          everyauth: {\n              myHostname: 'http://localhost:3000'\n            , appId: 'YOUR APP ID HERE'\n            , appSecret: 'YOUR APP SECRET HERE'\n            , redirectPath: '/'\n          }\n        }\n    });\n   \n    mongoose.model('User', UserSchema);\n\n    mongoose.connect('mongodb://localhost/example');\n\n    User = mongoose.model('User');\n\n    var app = express.createServer(\n        express.bodyParser()\n      , express.static(__dirname + \"/public\")\n      , express.cookieParser()\n      , express.session({ secret: 'esoognom'})\n      \n        // STEP 2: Add in the Routing\n      , mongooseAuth.middleware()\n\n        // IMPORTANT!!!!!!! Do not add app.router, to your middleware chain \n        // explicitly, or you will run into problems accessing `req.user`\n        // i.e., do not use app.use(app.router). Let express do this for you\n        // automatically for you upon your first app.get or app.post.\n    );\n   \n    // STEP 3: Add in Dynamic View Helpers (only if you are using express)\n    mongooseAuth.helpExpress(app);\n\n    app.listen(3000);\n```\n\n## View Helpers and Convenience Methods & Getters\n\nIn \"Step 3\" of the last code sample, we are adding dynamic view helpers, for if\nyou are using the [Express](https://github.com/visionmedia/express) web framework.\nThis automically gives you access to a convenient `everyauth` local variable from\nyour view, so you do not have to pass `req` as a local to your view:\n\n- `everyauth.loggedIn` - a Boolean getter that tells you if the request is by a logged in user\n- `everyauth.user` - the mongoose User document associated with the session\n- `everyauth.facebook` - The is equivalent to what is stored at `req.session.auth.facebook`, \n  so you can do things like ...\n- `everyauth.facebook.user` - returns the user json provided from the OAuth provider.\n- `everyauth.facebook.accessToken` - returns the access_token provided from the OAuth provider\n  for authorized API calls on behalf of the user.\n- And you also get this pattern for other modules - e.g., `everyauth.twitter.user`, \n  `everyauth.github.user`, etc.\n\nYou also get access to the view helper\n\n- `user` - the same as `everyauth.user` above\n\nAs an example of how you would use these, consider the following `./views/user.jade` jade template:\n\n    .user-id\n      .label User Id\n      .value #{user.id}\n    .facebook-id\n      .label User Facebook Id\n      .value #{everyauth.facebook.user.id}\n\nThe \"STEP 2: Add in the Routing\" step in the last code sample also provides convenience methods on the\n`ServerRequest` instance `req`. From any scope that has access to `req`, you get the following\nconvenience getter and method:\n\n- `req.loggedIn` - a Boolean getter that tells you if the request is by a logged in user\n- `req.user`     - the mongoose User document associated with the session\n- `req.logout()` - clears the sesion of your auth data\n\n## Using Multiple Authorization Strategies at Once\n\nYou can also use multiple authorization strategies in the same application.\nHere is an example, using 5 authorization strategies:\n\n```javascript\n    // A configuration file for holding all of your\n    // 3rd party OAuth credentials\n    var conf = require('./conf');\n    UserSchema.plugin(mongooseAuth, {\n        // Here, we attach your User model to every module\n        everymodule: {\n          everyauth: {\n              User: function () {\n                return User;\n              }\n          }\n        }\n      , facebook: {\n          everyauth: {\n              myHostname: 'http://localhost:3000'\n            , appId: conf.fb.appId\n            , appSecret: conf.fb.appSecret\n            , redirectPath: '/'\n          }\n        }\n      , twitter: {\n          everyauth: {\n              myHostname: 'http://localhost:3000'\n            , consumerKey: conf.twit.consumerKey\n            , consumerSecret: conf.twit.consumerSecret\n            , redirectPath: '/'\n          }\n        }\n      , password: {\n            everyauth: {\n                getLoginPath: '/login'\n              , postLoginPath: '/login'\n              , loginView: 'login.jade'\n              , getRegisterPath: '/register'\n              , postRegisterPath: '/register'\n              , registerView: 'register.jade'\n              , loginSuccessRedirect: '/'\n              , registerSuccessRedirect: '/'\n            }\n        }\n      , github: {\n          everyauth: {\n              myHostname: 'http://localhost:3000'\n            , appId: conf.github.appId\n            , appSecret: conf.github.appSecret\n            , redirectPath: '/'\n          }\n        }\n      , instagram: {\n          everyauth: {\n              myHostname: 'http://localhost:3000'\n            , appId: conf.instagram.clientId\n            , appSecret: conf.instagram.clientSecret\n            , redirectPath: '/'\n          }\n        }\n    });\n```\n\n## Example\n\nThere is an example app located in [./example](https://github.com/bnoguchi/mongoose-auth/tree/master/example).\nTo run it:\n\n    $ cd example\n    $ node server.js\n\nThen navigate to [http://localhost:3000/](http://localhost:3000)\n\n## Recipe 1: Linking Multiple Account Logins Together\n\nA common recipe is allowing a user to login via multiple accounts *and* to link those accounts under one user\ndocument.\n\nThis can be done in the following way:\n\nThe real magic lies with https://github.com/bnoguchi/everyauth/, and it should be more obvious once \nI document everyauth more and document mongoose-auth's relationship to everyauth.\n\nIn `everyauth`'s design, every auth module is defined as a set of steps, which are exposed in such a way for \nyou to over-ride. The step that is of particular interest for this scenario is the `findOrCreateUser` step \nrequired by every `everyauth` module.  `mongoose-auth` defines a default version of this `findOrCreateUser` \nstep for each `everyauth` auth module it supports (You can find these default definitions in \n\"lib/modules/#{moduleName}/everyauth.js\" -- e.g., see \n[.lib/modules/facebook/everyauth.js](https://github.com/bnoguchi/mongoose-auth/tree/master/lib/modules/facebook/everyauth.js)).\n\nSo for example, this is how you would over-ride the default `findOrCreateUser` step for the \nfacebook module if you are using both the facebook and password module:\n\n```javascript\nUserSchema.plugin(mongooseAuth, {\n  facebook: {\n    everyauth: {\n        myHostname: ...\n      , ...\n      , findOrCreateUser: function (session, accessTok, accessTokExtra, fbUser) {\n          var promise = this.Promise()\n              , User = this.User()();\n          User.findById(session.auth.userId, function (err, user) {\n            if (err) return promise.fail(err);\n            if (!user) {\n              User.where('password.login', fbUser.email).findOne( function (err, user) {\n                if (err) return promise.fail(err);\n                if (!user) {\n                  User.createWithFB(fbUser, accessTok, accessTokExtra.expires, function (err, createdUser) {\n                    if (err) return promise.fail(err);\n                    return promise.fulfill(createdUser);\n                  });\n                } else {\n                  assignFbDataToUser(user, accessTok, accessTokExtra, fbUser);\n                  user.save( function (err, user) {\n                    if (err) return promise.fail(err);\n                    promise.fulfill(user);\n                  });\n                }\n              });\n            } else {\n              assignFbDataToUser(user, accessTok, accessTokExtra, fbUser);\n              \n              // Save the new data to the user doc in the db\n              user.save( function (err, user) {\n                if (err) return promise.fail(err);\n                promise.fuilfill(user);\n              });\n            }\n          });\n        });\n        return promise; // Make sure to return the promise that promises the user\n      }\n  }\n});\n\n// Assign all properties - see lib/modules/facebook/schema.js for details\nfunction assignFbDataToUser (user, accessTok, accessTokExtra, fbUser) {\n  user.fb.accessToken = accessTok;\n  user.fb.expires = accessTokExtra.expires;\n  user.fb.id = fbUser.id;\n  user.fb.name.first = fbUser.first_name;\n  // etc. more assigning...\n}\n```\n\nAs this is a common recipe, I plan on adding support for this into `everyauth` and `mongoose-auth`, so it's more drop-in, and developers do not have to add this custom code themselves. The intent is for common things like this to be invisible to the developer, so it just *works* *like* *magic*. So, in the near future, you won't have to over-ride the findOrCreateUser step every time you want this feature. This will be coming soon.\n\n## Recipe 2: Configuring Email or Phone to be your Login for the Password Module\n\nBy default, `everyauth` and therefore `mongoose-auth` use the attribute `login` as the default attribute used for logging in\nwith the password module.\n\nHowever, the need can arise to use a different attribute (such as email) that implies a different schema (use `email: String` instead of `login: String`)\nin addition to different validation assumptions (email validations are more strict that login handle validations).\n\nLuckily, `mongoose-auth` provide support for this out of the box. All you need to do is (look for the line labeled \"THIS NEXT LINE IS THE ONLY ADDITION\"):\n\n```javascript\nUserSchema.plugin(mongooseAuth, {\n    // Here, we attach your User model to every module\n    everymodule: {\n      everyauth: {\n          User: function () {\n            return User;\n          }\n      }\n    }\n  , password: {\n        // THIS NEXT LINE IS THE ONLY ADDITION\n        loginWith: 'email' // Or loginWith: 'phone'\n\n      , everyauth: {\n            getLoginPath: '/login'\n          , postLoginPath: '/login'\n          , loginView: 'login.jade'\n          , getRegisterPath: '/register'\n          , postRegisterPath: '/register'\n          , registerView: 'register.jade'\n          , loginSuccessRedirect: '/'\n          , registerSuccessRedirect: '/'\n        }\n    }\n});\n```\n\nAutomatically, `mongoose-auth` will use an `email` String attribute in your User schema\ninstead of the default `login` String attribute. Moreover, it will automatically add in\nvalidation checks to make sure that the email is valid before registering a user through\nthe registration process of the password module.\n\n## Recipe 3: Extra password registration data besides login + password\n\nSometimes your registration will ask for more information from the user besides the login and password.\n\nFor this particular scenario, you can configure `extraParams`.\n\n```javascript\nUserSchema.plugin(mongooseAuth, {\n    // Here, we attach your User model to every module\n    everymodule: {\n      everyauth: {\n          User: function () {\n            return User;\n          }\n      }\n    }\n  , password: {\n        extraParams: {\n            phone: String\n          , name: {\n                first: String\n              , last: String\n            }\n        }\n\n      , everyauth: {\n            getLoginPath: '/login'\n          , postLoginPath: '/login'\n          , loginView: 'login.jade'\n          , getRegisterPath: '/register'\n          , postRegisterPath: '/register'\n          , registerView: 'register.jade'\n          , loginSuccessRedirect: '/'\n          , registerSuccessRedirect: '/'\n        }\n    }\n});\n```\n\nWhat this effectively does is:\n\n1. Adds `phone`, `name.first`, and `name.last` as attributes to your `UserSchema`.\n2. Automatically extracts the registration parameters after a visitor submits the registration\n   form and saves them to a new `User` document.\n   The registration form `<input>` `name`s should be, e.g., in the example above: 'phone', \n   'name[first]', and 'name[last]'.\n\nPlease see [./example/server.js](https://github.com/bnoguchi/mongoose-auth/tree/master/example/server.js#L45)\nfor a live example.\n\n## Recipe 4: Adding more attributes to your schema\n\nThis one ha come up enough that it is here as a recipe, even though it is not specific to `mongoose-auth`. Suppose\nyou want to add a special attribute such as `roles: [String]` to your UserSchema. This is something that you can do\nusing just `mongoose`\n\n```javascript\nvar UserSchema = new mongoose.Schema({\n    roles: [String]\n  , // other custom attributes\n});\n\nUserSchema.plugin(mongooseAuth, {\n  // mongooseAuth *adds* other attributes to your UserSchema\n  // depending on the auth modules you choose.\n});\n```\n\n## Recipe 5: Customizing how you do password login authentication\n\nCurrently, `mongoose-auth` does password authentication by login and password. Suppose you also want to authenticate\nby checking against an additional parameter, like `active`, which is a Boolean attribute on your UserSchema that\nindicates whether this user has been activated or not. Then you can modify the `authenticate` everyauth step in the\nfollowing way:\n\n```javascript\nvar UserSchema = new Schema({\n  active: Boolean\n}), User;\nUserSchema.plugin(mongooseAuth, {\n    everymodule: {\n      everyauth: {\n          User: function () {\n            return User;\n          }\n      }\n    }\n  , password: {\n        loginWith: 'email' \n      , everyauth: {\n            getLoginPath: '/login'\n          , postLoginPath: '/login'\n          , loginView: 'login.jade'\n          , getRegisterPath: '/register'\n          , postRegisterPath: '/register'\n          , registerView: 'register.jade'\n          , loginSuccessRedirect: '/'\n          , registerSuccessRedirect: '/'\n   \n            // WHAT YOU ADD IS THE FOLLOWING:\n            // The logic is adapted from the default authenticate\n            // implementation in lib/modules/password/everyauth.js\n          , authenticate: function (login, password) {\n              var promise\n                , errors = []; \n              if (!login) errors.push('Missing login.');\n              if (!password) errors.push('Missing password.');\n              if (errors.length) return errors;\n\n              promise = this.Promise();\n              this.User()().authenticate(login, password, function (err, user) {\n                if (err) {\n                  errors.push(err.message || err);\n                  return promise.fulfill(errors);\n                }   \n                if (!user) {\n                  errors.push('Failed login.');\n                  return promise.fulfill(errors);\n                }\n                \n                // The following block is the new code\n                if (!user.active) {\n                  errors.push('You are not yet activated.');\n                  return promise.fulfill(errors);\n                }\n                \n                promise.fulfill(user);\n              });\n              return promise;\n            }\n        }\n    }\n});\nmongoose.model('User', UserSchema);\n\nUser = mongoose.model('User');\n```\n\n### License\nMIT License\n\n---\n### Author\nBrian Noguchi\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/bnoguchi/mongoose-auth/issues"
  },
  "_id": "mongoose-auth@0.0.12",
  "_from": "mongoose-auth@0.0.12"
}
